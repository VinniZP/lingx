import { readFile, writeFile, mkdir } from 'fs/promises';
import { existsSync } from 'fs';
import { join, dirname } from 'path';
import { inferIcuParamTypes, type IcuParamType } from './icu-type-inferrer.js';

/**
 * Options for type generation
 */
export interface TypeGeneratorOptions {
  /** Path to translations directory */
  translationsPath: string;
  /** Source locale file name (e.g., 'en') */
  sourceLocale: string;
  /** Output path for generated .d.ts file */
  outputPath: string;
  /** File pattern to find locale files (e.g., '{lang}.json') */
  filePattern: string;
  /** Whether translations are nested objects */
  nested: boolean;
}

/**
 * Represents a parsed translation entry with type information
 */
interface TranslationEntry {
  /** Dot-notation key (e.g., 'auth.login.title') */
  key: string;
  /** Original translation value */
  value: string;
  /** Inferred ICU parameter types */
  params: IcuParamType[];
}

/**
 * Result of type generation
 */
export interface TypeGeneratorResult {
  /** Number of translation keys processed */
  keyCount: number;
  /** Number of keys with ICU parameters */
  keysWithParams: number;
  /** Output file path */
  outputPath: string;
}

/**
 * Generates TypeScript type definitions from translation files.
 *
 * Creates a .d.ts file that augments the @localeflow/sdk-nextjs module
 * with type-safe translation keys and ICU parameter types.
 */
export async function generateTypes(
  options: TypeGeneratorOptions
): Promise<TypeGeneratorResult> {
  // Build path to source locale file
  const fileName = options.filePattern.replace('{lang}', options.sourceLocale);
  const filePath = join(options.translationsPath, fileName);

  if (!existsSync(filePath)) {
    throw new Error(
      `Source locale file not found: ${filePath}\n` +
        `Please ensure the file exists or check your config.`
    );
  }

  // Read and parse translations
  const content = await readFile(filePath, 'utf-8');
  const rawTranslations = JSON.parse(content);

  // Flatten nested translations to dot-notation
  const flatTranslations = options.nested
    ? flattenObject(rawTranslations)
    : rawTranslations;

  // Process each translation to extract type information
  const entries: TranslationEntry[] = [];
  for (const [key, value] of Object.entries(flatTranslations)) {
    if (typeof value !== 'string') continue;

    const params = inferIcuParamTypes(value);
    entries.push({ key, value, params });
  }

  // Generate TypeScript declaration content
  const declarationContent = generateDeclarationFile(entries);

  // Ensure output directory exists
  const outputDir = dirname(options.outputPath);
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  // Write declaration file
  await writeFile(options.outputPath, declarationContent, 'utf-8');

  return {
    keyCount: entries.length,
    keysWithParams: entries.filter((e) => e.params.length > 0).length,
    outputPath: options.outputPath,
  };
}

/**
 * Flattens a nested object to dot-notation keys
 */
function flattenObject(
  obj: Record<string, unknown>,
  prefix = ''
): Record<string, string> {
  const result: Record<string, string> = {};

  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;

    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      Object.assign(result, flattenObject(value as Record<string, unknown>, fullKey));
    } else if (typeof value === 'string') {
      result[fullKey] = value;
    }
  }

  return result;
}

/**
 * Escapes a string for use in JSDoc comments
 */
function escapeJsDoc(str: string): string {
  return str
    .replace(/\*/g, '\\*')
    .replace(/\//g, '\\/')
    .replace(/\n/g, ' ')
    .substring(0, 100) + (str.length > 100 ? '...' : '');
}

/**
 * Generates the TypeScript declaration file content
 */
function generateDeclarationFile(entries: TranslationEntry[]): string {
  // Sort entries alphabetically
  const sortedEntries = [...entries].sort((a, b) => a.key.localeCompare(b.key));

  // Generate TranslationKeys union type
  const keysUnion = sortedEntries
    .map((e) => `  | '${e.key}'`)
    .join('\n');

  // Generate TranslationParams interface
  const paramsEntries = sortedEntries
    .filter((e) => e.params.length > 0)
    .map((e) => {
      const paramType = e.params.map((p) => `${p.name}: ${p.type}`).join('; ');
      const jsdoc = `    /** ${escapeJsDoc(e.value)} */`;
      return `${jsdoc}\n    '${e.key}': { ${paramType} };`;
    })
    .join('\n');

  // Build the full declaration file
  // Note: We use interface merging to augment the SDK types
  // The SDK defines TranslationResources as an empty interface that we extend here
  return `// This file is auto-generated by LocaleFlow CLI
// Do not edit manually. Run 'localeflow types' to regenerate.

import '@localeflow/sdk-nextjs';

declare module '@localeflow/sdk-nextjs' {
  /**
   * Generated translation resources.
   * This interface is merged with the SDK's TranslationResources.
   */
  interface TranslationResources {
    /**
     * All available translation keys.
     * Generated from source locale translations.
     */
    keys:
${keysUnion};
  }

  /**
   * ICU parameter types for translation keys that require parameters.
   * Keys not listed here don't require parameters.
   */
  interface TranslationParams {
${paramsEntries || '    // No keys with parameters'}
  }
}
`;
}

export { inferIcuParamTypes, type IcuParamType } from './icu-type-inferrer.js';
